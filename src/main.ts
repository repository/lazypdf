import appRoot from "app-root-path";
import dotenv from "dotenv";
import express from "express";
import fs from "fs/promises";
import glob from "glob-promise";
import hljs from "highlight.js";
import http from "http";
import path from "path";
import pdf from "pdfjs";
import prettyBytes from "pretty-bytes";
import puppeteer from "puppeteer";

import { codePdfTemplate, pagePdfTemplate } from "./templates";

dotenv.config();
const heading = process.env.HEADING ?? "Generated by LazyPDF";

const INPUT_DIR = appRoot.resolve("input");
const OUTPUT_DIR = appRoot.resolve("output");

interface CodeFile {
  path: string;
  codePdf: Buffer | null;
}

interface HtmlFile extends CodeFile {
  pagePdf: Buffer | null;
}

interface InputFolder {
  name: string;
  root: string;
  files: (HtmlFile | CodeFile)[];
}

function isHtmlFile(obj: any): obj is HtmlFile {
  return typeof (obj as HtmlFile).pagePdf !== "undefined";
}

function toPosix(path: string) {
  return path.replace(/\\/g, "/");
}

function startExpress(app: express.Express) {
  return new Promise<http.Server>((resolve, reject) => {
    try {
      const server = app.listen(0, () => {
        resolve(server);
      });
    } catch (err) {
      reject(err);
    }
  });
}

function stopServer(server: http.Server) {
  return new Promise<void>((resolve, reject) => {
    server.close((err) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

async function getPageHeight(page: puppeteer.Page) {
  const height = await page
    .$("html")
    .then((element) => element?.boundingBox())
    .then((box) => box?.height);

  if (!height) {
    throw new Error("Could not get height of page");
  }

  return height;
}

async function generatePagePdfs(input: InputFolder, browser: puppeteer.Browser) {
  const app = express();
  app.use(express.static(input.root));

  const server = await startExpress(app);
  const address = server.address();

  if (typeof address === "string" || address === null) {
    await stopServer(server);
    throw new Error(`Address is '${address}'. This can't be good.`);
  }

  const url = `http://127.0.0.1:${address.port}`;

  const htmlFiles = input.files.filter(isHtmlFile);

  await Promise.all(
    htmlFiles.map(async (file) => {
      const page = await browser.newPage();

      await page.goto(`${url}/${file.path}`, { waitUntil: "networkidle0" });

      const pageHeight = await page.evaluate(() => {
        const bodyStyle = window.getComputedStyle(document.body);

        return (
          parseFloat(bodyStyle.getPropertyValue("margin-top")) +
          parseFloat(bodyStyle.getPropertyValue("margin-bottom")) +
          document.body.scrollHeight
        );
      });

      await page.setViewport({ width: 1200, height: pageHeight });

      const screenshot = await page.screenshot({ type: "png", fullPage: true, encoding: "base64" });

      if (typeof screenshot !== "string") {
        throw new Error("Failed to screenshot page");
      }

      const template = pagePdfTemplate(screenshot, file.path, heading);

      await page.setContent(template, { waitUntil: "networkidle0" });
      await page.setViewport({ width: 1200, height: 1e6 });

      const pdfPageHeight = await getPageHeight(page);

      file.pagePdf = await page.pdf({ printBackground: true, width: 1200, height: pdfPageHeight + 1 });

      await page.close();
    }),
  );
}

async function generateCodePdfs(input: InputFolder, browser: puppeteer.Browser) {
  await Promise.all(
    input.files.map(async (file) => {
      const page = await browser.newPage();

      const code = await fs.readFile(path.join(input.root, file.path), "utf8");

      // find a better solution for this!!
      const extension = path.extname(file.path).replace(/^\./, "");

      const highlighted = hljs.highlight(code, { language: extension }).value;

      const lines = code.split("\n").length;
      const bytes = prettyBytes(Buffer.byteLength(code, "utf8"));

      const formattedTemplate = codePdfTemplate(highlighted, file.path, `${lines} lines (${bytes})`, heading);

      await page.setContent(formattedTemplate, { waitUntil: "networkidle0" });
      await page.setViewport({ width: 1200, height: 1e6 });

      const height = await getPageHeight(page);

      file.codePdf = await page.pdf({
        printBackground: true,
        width: 1200,
        height: height + 1,
      });

      await page.close();
    }),
  );
}

async function mergePdfs(input: InputFolder, outputDir: string) {
  const doc = new pdf.Document();

  const htmlFiles = input.files.filter(isHtmlFile);

  for (const file of htmlFiles) {
    if (!file.pagePdf) {
      throw new Error(`Missing page PDF for ${input.name}: ${file.path}`);
    }

    const extPdf = new pdf.ExternalDocument(file.pagePdf);
    doc.addPageOf(1, extPdf);
  }

  for (const file of input.files) {
    if (!file.codePdf) {
      throw new Error(`Missing code PDF for ${input.name}: ${file.path}`);
    }

    const extPdf = new pdf.ExternalDocument(file.codePdf);
    doc.addPageOf(1, extPdf);
  }

  const outputPath = path.join(outputDir, `${input.name}.pdf`);

  await fs.writeFile(outputPath, await doc.asBuffer());
  return outputPath;
}

async function main() {
  const inputDirs = (await fs.readdir(INPUT_DIR, { withFileTypes: true }))
    .filter((d) => d.isDirectory())
    .map((d) => d.name);

  if (inputDirs.length === 0) {
    console.error("No input directories found");
    return;
  } else {
    console.log(`Found ${inputDirs.length} input directories\n  ${inputDirs.join()}`);
  }

  const inputs: InputFolder[] = await Promise.all(
    inputDirs.map(async (inputDir) => {
      const files = await glob(path.join(INPUT_DIR, inputDir, "**/*.*")).then((files) =>
        files.map((file) => toPosix(path.relative(path.join(INPUT_DIR, inputDir), file))),
      );

      return {
        name: inputDir,
        root: toPosix(path.resolve(INPUT_DIR, inputDir)),
        files: files.map((file) => ({
          path: file,
          codePdf: null,
          ...(file.endsWith(".html") && { pagePdf: null }),
        })),
      };
    }),
  );

  const browser = await puppeteer.launch({ args: ["--disable-web-security"], headless: true });

  await Promise.all(
    inputs
      .map(async (input) => {
        await Promise.all([generatePagePdfs(input, browser), generateCodePdfs(input, browser)]);
        return input;
      })
      .map((pInput) => pInput.then((input) => mergePdfs(input, OUTPUT_DIR))),
  );
  console.log("Done!");
}
main();
